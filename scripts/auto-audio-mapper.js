#!/usr/bin/env node

/**
 * Auto Audio Mapper
 * 
 * This script automatically generates audio mappings by scanning the assets/audio directory
 * and creating the necessary TypeScript mappings. This eliminates the need for manual
 * audio mapping in AudioService.ts and dictionaryAudio.ts
 * 
 * Usage: node scripts/auto-audio-mapper.js
 */

const fs = require('fs');
const path = require('path');

// Configuration
const AUDIO_DIR = path.join(__dirname, '../assets/audio');
const OUTPUT_DIR = path.join(__dirname, '../app/services');
const TEMP_DIR = path.join(__dirname, '../temp');

// Audio file extensions to process
const AUDIO_EXTENSIONS = ['.mp3', '.wav', '.m4a', '.aac'];

/**
 * Recursively scan directory for audio files
 */
function scanAudioFiles(dir, basePath = '') {
  const files = [];
  
  try {
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const relativePath = path.join(basePath, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        files.push(...scanAudioFiles(fullPath, relativePath));
      } else if (stat.isFile() && AUDIO_EXTENSIONS.includes(path.extname(item))) {
        files.push({
          fullPath,
          relativePath: relativePath.replace(/\\/g, '/'), // Normalize to forward slashes
          filename: item,
          key: generateKey(relativePath, item)
        });
      }
    }
  } catch (error) {
    console.warn(`Warning: Could not read directory ${dir}:`, error.message);
  }
  
  return files;
}

/**
 * Generate a key for the audio file
 */
function generateKey(relativePath, filename) {
  // Remove extension
  const nameWithoutExt = path.parse(filename).name;
  
  // Convert path to key format
  let key = relativePath.replace(/\\/g, '/').replace(/\//g, '_');
  key = key.replace(/\.(mp3|wav|m4a|aac)$/, '');
  
  // Clean up the key
  key = key
    .replace(/[^a-zA-Z0-9_-]/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_|_$/g, '');
  
  return key;
}

/**
 * Generate TypeScript code for AudioService.ts
 */
function generateAudioServiceCode(audioFiles) {
  const imports = [];
  const mappings = [];
  
  for (const file of audioFiles) {
    const requirePath = `../../assets/audio/${file.relativePath}`;
    imports.push(`  '${file.key}': require('${requirePath}'),`);
  }
  
  return `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// This file is automatically generated by scripts/auto-audio-mapper.js
// Run 'npm run map-audio' to regenerate

const audioMap: Record<string, any> = {
${imports.join('\n')}
};

export { audioMap };
`;
}

/**
 * Generate TypeScript code for dictionary audio
 */
function generateDictionaryAudioCode(audioFiles) {
  const dictionaryFiles = audioFiles.filter(file => 
    file.relativePath.startsWith('dictionary_words/')
  );
  
  const mappings = [];
  
  for (const file of dictionaryFiles) {
    const requirePath = `../../assets/audio/${file.relativePath}`;
    const key = path.parse(file.filename).name.split('-')[0]; // Extract word before first hyphen
    
    if (key) {
      mappings.push(`  '${key}': require('${requirePath}'),`);
    }
  }
  
  return `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// This file is automatically generated by scripts/auto-audio-mapper.js
// Run 'npm run map-audio' to regenerate

export const dictionaryAudioMap: Record<string, any> = {
${mappings.join('\n')}
};

export function normalizeDzKey(input: string): string {
  // lower, strip accents, replace spaces with underscore
  const lower = input.toLowerCase();
  const stripped = lower.normalize('NFD').replace(/\\p{M}+/gu, '');
  return stripped.replace(/\\s+/g, '_');
}
`;
}

/**
 * Update existing AudioService.ts to use auto-generated mappings
 */
function updateAudioService(audioFiles) {
  const audioServicePath = path.join(OUTPUT_DIR, 'AudioService.ts');
  const autoMapperPath = path.join(OUTPUT_DIR, 'autoAudioMap.ts');
  
  if (!fs.existsSync(audioServicePath)) {
    console.warn('AudioService.ts not found, skipping update');
    return;
  }
  
  let content = fs.readFileSync(audioServicePath, 'utf8');
  
  // Replace the manual audioMap with import from auto-generated file
  const importStatement = "import { audioMap } from './autoAudioMap';";
  const oldImportPattern = /import.*dictionaryAudio.*from.*dictionaryAudio.*;?/;
  
  if (oldImportPattern.test(content)) {
    content = content.replace(oldImportPattern, importStatement);
  } else {
    // Add import if it doesn't exist
    const importIndex = content.indexOf('import { Audio }');
    if (importIndex !== -1) {
      const nextLineIndex = content.indexOf('\n', importIndex) + 1;
      content = content.slice(0, nextLineIndex) + importStatement + '\n' + content.slice(nextLineIndex);
    }
  }
  
  // Remove the old manual audioMap definition
  const oldMapPattern = /const audioMap: Record<string, any> = \{[\s\S]*?\};/;
  content = content.replace(oldMapPattern, '');
  
  // Update the playAudio method to use the new map
  content = content.replace(
    /let key = filename && audioMap\[filename\] \? filename : undefined;/,
    `let key = filename && audioMap[filename] ? filename : undefined;`
  );
  
  fs.writeFileSync(audioServicePath, content);
  console.log('‚úÖ Updated AudioService.ts to use auto-generated mappings');
}

/**
 * Main function
 */
function main() {
  console.log('üéµ Auto Audio Mapper Starting...\n');
  
  // Create temp directory if it doesn't exist
  if (!fs.existsSync(TEMP_DIR)) {
    fs.mkdirSync(TEMP_DIR, { recursive: true });
  }
  
  // Scan for audio files
  console.log('üìÅ Scanning for audio files...');
  const audioFiles = scanAudioFiles(AUDIO_DIR);
  
  if (audioFiles.length === 0) {
    console.log('‚ùå No audio files found in assets/audio/');
    return;
  }
  
  console.log(`‚úÖ Found ${audioFiles.length} audio files\n`);
  
  // Generate auto-generated files
  console.log('üîß Generating auto-mapped audio files...');
  
  const autoAudioMapContent = generateAudioServiceCode(audioFiles);
  const autoAudioMapPath = path.join(OUTPUT_DIR, 'autoAudioMap.ts');
  fs.writeFileSync(autoAudioMapPath, autoAudioMapContent);
  console.log('‚úÖ Generated autoAudioMap.ts');
  
  const dictionaryAudioContent = generateDictionaryAudioCode(audioFiles);
  const dictionaryAudioPath = path.join(OUTPUT_DIR, 'dictionaryAudio.ts');
  fs.writeFileSync(dictionaryAudioPath, dictionaryAudioContent);
  console.log('‚úÖ Updated dictionaryAudio.ts');
  
  // Update AudioService.ts
  console.log('üîß Updating AudioService.ts...');
  updateAudioService(audioFiles);
  
  // Generate summary
  console.log('\nüìä Summary:');
  console.log(`   Total audio files: ${audioFiles.length}`);
  console.log(`   Dictionary words: ${audioFiles.filter(f => f.relativePath.startsWith('dictionary_words/')).length}`);
  console.log(`   Conversations: ${audioFiles.filter(f => f.relativePath.startsWith('conversations/')).length}`);
  console.log(`   Other: ${audioFiles.filter(f => !f.relativePath.startsWith('dictionary_words/') && !f.relativePath.startsWith('conversations/')).length}`);
  
  console.log('\nüéâ Audio mapping completed successfully!');
  console.log('\nüìù Next steps:');
  console.log('   1. Review the generated files in app/services/');
  console.log('   2. Test the app to ensure audio still works');
  console.log('   3. Commit the changes');
  console.log('\nüí° To regenerate mappings in the future, run: npm run map-audio');
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { main, scanAudioFiles, generateAudioServiceCode, generateDictionaryAudioCode };
